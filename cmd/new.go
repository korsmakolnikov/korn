package cmd

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"text/template"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

const (
	defaultBuildName = "kornvim"
	initLuaTemplate  = `
-- init.lua
-- Neovim configuration file generated by kornvim.lua

-- Get the current working directory using a built-in Neovim function.
-- This works on all operating systems (Linux, macOS, Windows).
local config_dir = vim.fn.getcwd()
local build_name = "{{.BuildName}}"

-- Get the optional "testing" flag from the environment
-- local testing_flag = os.getenv("KORNVIM_TEST_FLAG")
local testing_flag = 1
local lazy_root_dir

-- Lazy.nvim plugin manager setup.
if testing_flag then
  lazy_root_dir = config_dir .. "/" .. build_name .. "/lazy"
else
  lazy_root_dir = vim.fn.stdpath("data") .. "/lazy"
end

local lazypath = lazy_root_dir .. "/lazy.nvim"

if not vim.loop.fs_stat(lazypath) then
  vim.fn.system({
    "git",
    "clone",
    "--filter=blob:none",
    "https://github.com/folke/lazy.nvim.git",
    "--branch=stable",
    lazypath,
  })
end
vim.opt.rtp:prepend(lazypath)

-- Run Lazy.nvim with your plugins loaded from a separate module.
require("lazy").setup(require("packages").setup(), { root = lazy_root_dir })
`

	packageLuaTemplate = `
-- lua/packages.lua
-- This file contains the list of all your Neovim plugins.

local M = {}

-- The 'setup' function returns the list of plugins.
function M.setup()
  return {
    -- Lazy.nvim itself.
    "folke/lazy.nvim",

    -- Your custom plugin.
    {
      "{{.CustomPlugin}}",
      config = function()
        require('{{.PackageName}}').setup()
      end
    },

    -- Add more plugins here.
    -- E.g., "nvim-telescope/telescope.nvim"
    -- E.g., { "nvim-lualine/lualine.nvim", config = function() ... end }
  }
end

return M
`
)

var newCmd = &cobra.Command{
	Use:   "new [path of the custom nvim configuration folder]",
	Short: "generates a basic nvim configuration in a custom directory, installing lazy and a plugin of your choice with your custom configuration",
	Args:  cobra.MinimumNArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		executeNew(cmd, args)
	},
}

func executeNew(_ *cobra.Command, args []string) {
	buildName := defaultBuildName
	if len(args) > 0 {
		buildName = args[0]
	}

	customPlugin := viper.GetString("custom_plugin")

	// creates the build directory and the lua child directory
	buildPath := buildPath(buildName)
	luaFolderPath := fmt.Sprintf("%s/lua/", buildPath)
	log.Println("Creating the directory", buildPath)
	if err := os.MkdirAll(luaFolderPath, os.ModePerm); err != nil {
		log.Fatalln("cannot create lua directory in the setting directory", err)
	}

	initFilePath := fmt.Sprintf("%s/init.lua", buildPath)
	initData := struct {
		BuildName string
	}{
		BuildName: buildName,
	}
	executeLuaTemplate(initFilePath, initLuaTemplate, initData)

	packageFilePath := fmt.Sprintf("%s/packages.lua", luaFolderPath)
	packageData := struct {
		CustomPlugin string
		PackageName  string
	}{
		CustomPlugin: customPlugin,
		PackageName:  guessRepoName(customPlugin),
	}
	executeLuaTemplate(packageFilePath, packageLuaTemplate, packageData)
}

func buildPath(buildName string) string {
	return fmt.Sprintf("./%s/", buildName)
}

func init() {
	rootCmd.AddCommand(newCmd)
}

func executeLuaTemplate(filePath string, luaTemplate string, data any) {
	file, err := os.Create(filePath)
	if err != nil {
		log.Fatalf("Error while creating %s file: %+v", filePath, err)
	}
	defer file.Close()

	tmpl, err := template.New(filePath).Parse(luaTemplate)
	if err != nil {
		log.Fatalf("Error while parsing %s file template: %+v", filePath, err)
	}

	if err := tmpl.Execute(file, data); err != nil {
		log.Fatalf("Error while execution of %s file template failed: %+v", filePath, err)
	}

	log.Printf("%s file has been successfully generated", filePath)
}

func guessRepoName(pluginNamespace string) string {
	return filepath.Base(pluginNamespace)
}
